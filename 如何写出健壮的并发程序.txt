1. 迫不得已才使用低级同步原语。低级同步原语主要是指synchronized, Lock, Semaphore，这些看似简单但使用起来却没有那么简单，容易引发问题，一定要谨慎使用，使用时要满足下面的几条准则：
永远只在更新对象的成员变量时加锁 　没有更新就不存在互斥问题，也就不需要加锁。
永远只在访问可变的成员变量时加锁　不可变的成员变量本身就是线程安全的。
永远不在调用其他对象的方法时加锁　可能其他类有方法也会加锁，就有可能造成死锁；即使其他类没有加锁，也可能存在很慢的IO操作，或sleep()调用，导致性能问题。

2. 优先使用成熟的工具类，比如Java SDK提供的ConCurrentHashMap，　CopyonWriteArrayList等数据结构，比如Java 8提供的CompletableFuture和CompletableService，比如distrutor框架。

3. 避免过早优化，并发程序首先保证安全性，出现性能瓶颈后再优化。

4. 注意安全性、活跃性和性能问题
1）安全性：
数据竞争： 多个线程同时访问一个数据，并且至少有一个线程会写这个数据。
竞态条件： 程序的执行结果依赖程序执行的顺序。
也可以按照以下的方式理解竞态条件： 程序的执行依赖于某个状态变量，在判断满足条件的时候执行，但是在执行时其他变量同时修改了状态变量。
if (状态变量 满足 执行条件) {
  执行操作
}
问题： 数据竞争一定会导致程序存在竞态条件吗？有没有什么相关性？

2）活跃性：
死锁、活锁、饥饿
这里解释一下什么是饥饿：举个例子前面提到的要尽量用notifyAll而不是notify，就是为了防止饥饿，即某个线程
长期得不到调度；还有是ReenTrantLock,可以指定公平锁，那么等待最长的线程会优先获取锁，这也就防止了饥饿。

3）性能：
核心就是在保证安全性和活跃性的前提下，根据实际情况，尽量降低锁的粒度。即尽量减少持有锁的时间。
JDK的并发包里，有很多特定场景针对并发性能的设计。例如使用细粒度的锁，
一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；
还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。
还有很多无锁化的设计，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；
Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……